Eigen::Vector3f displacement_fragment_shader(const fragment_shader_payload& payload)
{
    // 基础材质参数
    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);
    Eigen::Vector3f kd = payload.color;
    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);

    // 光源信息
    auto l1 = light{{20, 20, 20}, {500, 500, 500}};
    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};
    std::vector<light> lights = {l1, l2};
    Eigen::Vector3f amb_light_intensity{10, 10, 10};
    Eigen::Vector3f eye_pos{0, 0, 10};

    float p = 150; // 高光指数

    Eigen::Vector3f color = payload.color; 
    Eigen::Vector3f point = payload.view_pos; // 视线空间中的原始点
    Eigen::Vector3f normal = payload.normal.normalized();

    // Displacement Mapping 参数
    float kh = 0.2; // 高度缩放系数
    float kn = 0.1; // 法线扰动强度 (在Displacement Mapping中可能次要)

    // 纹理坐标
    float u = payload.tex_coords.x();
    float v = payload.tex_coords.y();
    float w = payload.texture->width;
    float h = payload.texture->height;

    // 1. 计算TBN矩阵 (与Bump Mapping相同)
    Vector3f t; // Tangent
    // ... 计算切线t (参考Bump Mapping代码)
    t << (normal.x() * normal.y()) / sqrt(normal.x() * normal.x() + normal.z() * normal.z()),
         sqrt(normal.x() * normal.x() + normal.z() * normal.z()),
         (normal.z() * normal.y()) / sqrt(normal.x() * normal.x() + normal.z() * normal.z());
    t.normalize();
    Vector3f b = normal.cross(t); // Bitangent
    b.normalize();
    Matrix3f TBN;
    TBN << t.x(), b.x(), normal.x(),
           t.y(), b.y(), normal.y(),
           t.z(), b.z(), normal.z();

    // 2. 将视线向量(view vector)和起点转换到切线空间
    // 视线向量 V: 从片元指向眼睛
    Eigen::Vector3f view_dir = (eye_pos - point).normalized();
    // 转换到切线空间
    Eigen::Vector3f view_dir_tangent = TBN.inverse() * view_dir; // 或者使用转置，因为TBN是正交矩阵
    view_dir_tangent.normalize(); // 确保归一化

    // 光线步进(Raymarching)的起点：可以认为是当前片元在切线空间中的位置 (u, v, height)
    // 初始高度通常为0（表面），但也可以从高度图采样起始点的高度
    float current_u = u;
    float current_v = v;
    float current_height = 0.0f; // 假设初始在表面上

    // 光线步进参数
    const int num_steps = 50; // 最大步数
    float step_size = 0.01f; // 步长 (需要根据高度范围调整)
    float ray_length = 0.0f;

    // 3. 光线步进循环 (在切线空间中)
    for (int i = 0; i < num_steps; ++i) {
        // 计算当前点在切线空间中的“真实”高度 (来自纹理)
        float texture_height = payload.texture->getColor(current_u, current_v).norm() * kh; // 用norm()近似高度，并用kh缩放

        // 如果当前射线点的高度小于纹理高度，说明我们已经进入表面之下（相交）
        if (current_height >= texture_height) {
            // 找到交点，可以跳出循环
            // 更精确的做法可以使用二分查找等在这个区间内进一步 refine 交点
            break;
        }

        // 如果没有相交，则沿视线方向前进一步
        ray_length += step_size;
        // 更新当前点在切线空间中的UV坐标和高度
        // view_dir_tangent 是单位向量，所以每一步移动 step_size 个单位
        current_u += step_size * view_dir_tangent.x() / (view_dir_tangent.z() + 1e-5); // 防止除零，粗略的透视修正
        current_v += step_size * view_dir_tangent.y() / (view_dir_tangent.z() + 1e-5);
        current_height += step_size * view_dir_tangent.z(); // Z方向代表高度变化

        // 可选：如果射线离开纹理坐标范围或高度范围过大，可提前终止
        if (current_u < 0 || current_u > 1 || current_v < 0 || current_v > 1 || ray_length > 1.0f) {
            // 未找到有效交点，可以使用原始位置或丢弃片元
            // 这里简单使用原始位置
            current_u = u;
            current_v = v;
            current_height = 0;
            break;
        }
    }

    // 4. 在交点处(current_u, current_v)计算新的法线 (类似于Bump Mapping，但使用位移后的UV)
    // 计算高度梯度
    float dU = kh * kn * (payload.texture->getColor(current_u + 1.0f/w, current_v).norm() - payload.texture->getColor(current_u, current_v).norm());
    float dV = kh * kn * (payload.texture->getColor(current_u, current_v + 1.0f/h).norm() - payload.texture->getColor(current_u, current_v).norm());
    // 切线空间中的新法线
    Vector3f n_tangent;
    n_tangent << -dU, -dV, 1.0f;
    n_tangent.normalize();
    // 将法线转换回世界/视图空间
    Vector3f new_normal = (TBN * n_tangent).normalized();

    // 5. (可选) 如果需要更精确，可以计算位移后的3D位置
    // 这需要将切线空间中的位移向量转换回世界空间
    // Eigen::Vector3f displaced_point = point + (TBN * Eigen::Vector3f(0, 0, current_height)); // 这是一种近似

    // 6. 使用新的法线进行Blinn-Phong光照计算 (使用原始点或近似位移点)
    // 注意：光照计算通常基于视图空间或世界空间的位置和法线
    Eigen::Vector3f result_color = {0, 0, 0};
    Eigen::Vector3f ambient = ka.cwiseProduct(amb_light_intensity);

    for (auto& light : lights) {
        Eigen::Vector3f light_dir = (light.position - point).normalized(); // 使用原始点或 displaced_point
        Eigen::Vector3f view_dir = (eye_pos - point).normalized(); // 使用原始点或 displaced_point
        Eigen::Vector3f half_dir = (light_dir + view_dir).normalized();

        float r_square = (light.position - point).squaredNorm(); // 使用原始点或 displaced_point

        float diffuse_factor = std::max(0.0f, new_normal.dot(light_dir));
        Eigen::Vector3f diffuse = kd.cwiseProduct(light.intensity / r_square) * diffuse_factor;

        float specular_factor = std::pow(std::max(0.0f, new_normal.dot(half_dir)), p);
        Eigen::Vector3f specular = ks.cwiseProduct(light.intensity / r_square) * specular_factor;

        result_color += (diffuse + specular);
    }
    result_color += ambient;

    return result_color * 255.f;
}